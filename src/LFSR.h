/*
* File:   LFSR.h
* Author: Daedalus
*
* Created on May 5, 2015
*/

#ifndef LFSR_H
#define	LFSR_H

class LFSR {
	// An implementation of a linear feedback shift register
	// psudo-random number generator.

	// Number of bits used in the LFSR.  Should be a mulitple of 64.
	const static int length = 256;

	// Number of taps used for feedback.  4 is sufficient for maximum
	// length operation.  Code cannot handle different values.
	const static int numtaps = 4;

	// Array which stores the prime numbers generated by the Sieve().
	int primes[length + 1];

	// Tracking variable for the number of primes in the primes array.
	int numprimes;

	// Union which allows the internal state of the LFSR to be accessed
	// in several ways for convenience.
	union internal {
		unsigned long l[length / 64];
		unsigned short s[length / 16];
		unsigned char c[length / 8];
	} state;

	// Struct to contain the information about the taps, including
	// its position in terms of bits, which byte in the internal state
	// it is in, and its place within that byte.
	struct tapstruct {
		int bit;
		int byte;
		int place;
	};

	// Array which stores the taps for this LFSR.
	tapstruct tap[numtaps];

	// Calculates the byte location and place in that byte of each tap.
	void SetupTaps();

	// Methods for setting the value of a bit in the specified integer.
	void SetBit(unsigned char*, int, bool);
	void SetBit(unsigned long*, int, bool);

	// Methods for reading the value of a bit in the specified integer.
	bool ReadBit(unsigned char, int);
	bool ReadBit(unsigned long, int);

	// Shift the register and generate and return the output bit.
	bool Clock();

	// Generate a list of prime numbers
	void Sieve();

public:

	// Initialization method for the LFSR.  Chooses tap locations
	// and sets the initial state as the given char[].
	bool Setup(char*);

	// Empty constructor.  Necessary for implementation.
	LFSR();

	// Generate and return 8 psudo-random bits as an unsigned char.
	unsigned char NextChar();

};

#endif	/* LFSR_H */